import java.io.{File, PrintWriter}

import com.typesafe.config.{Config, ConfigFactory}
import com.typesafe.scalalogging.StrictLogging
import java.util.ServiceConfigurationError

import org.mmisw.orr.ont._
import org.mmisw.orr.ont.app._
import org.mmisw.orr.ont.service._
import org.mmisw.orr.ont.util.Emailer
import org.scalatra._
import javax.servlet.ServletContext

import org.apache.jena.system.JenaSystem

import scala.util.control.NonFatal


class ScalatraBootstrap extends LifeCycle with StrictLogging {
  JenaSystem.init()

  private[this] var setupOpt: Option[Setup] = None

  private[this] val configDir: File = {
    val baseAppConfig: Config = ConfigFactory.load
    new File(baseAppConfig.getString("configDir"))
  }

  override def init(context: ServletContext) {

    logger.info(s"contextPath = '${context.getContextPath}'")

    if (!configDir.isDirectory) {
      throw new ServiceConfigurationError(s"$configDir: is not a directory.")
    }

    val config = {
      val configFile = new File(configDir, "orront.conf")
      logger.info(s"Loading configuration from $configFile")
      if (!configFile.canRead) {
        throw new ServiceConfigurationError("Could not read configuration file " + configFile)
      }
      ConfigFactory.parseFile(configFile).resolve()
    }
    val cfg = Cfg(config)

    implicit val setup: Setup = {
      val emailer = new Emailer(cfg.email)
      val notifier = new Notifier(configDir, emailer)
      new Setup(cfg, emailer, notifier)
    }
    implicit val ontService: OntService = new OntService
    implicit val tsService: TripleStoreService = new TripleStoreServiceAgRest

    context.mount(new OrgController,           "/api/v0/org/*")
    context.mount(new UserController,          "/api/v0/user/*")
    context.mount(new OntController,           "/api/v0/ont/*")
    context.mount(new TermController,          "/api/v0/term/*")
    context.mount(new TripleStoreController,   "/api/v0/ts/*")
    context.mount(new ApiDocs,                 "/api-docs")
    context.mount(new SelfHostedOntController, "/*")

    setOrrPortalStuff(context, setup.cfg)

    setupOpt = Some(setup)
  }

  override def destroy(context: ServletContext) {
    setupOpt foreach { _.destroy() }
  }

  private def setOrrPortalStuff(context: ServletContext, cfg: Cfg): Unit = {
    def existsUnderMyContext(path: String): Boolean =
      Option(context.getRealPath(path)).exists(new File(_).isFile)

    if (existsUnderMyContext("/index.html")) {
      try {
        setLocalConfigJs()
        adjustIndexHtmls()
      }
      catch {
        case NonFatal(e) ⇒ logger.error("setting local.config.js or index.html files", e)
      }
    }
    else logger.info(s"setOrrPortalStuff: index.html not found so nothing to do")

    import java.nio.file.{Paths, Files}

    def setLocalConfigJs(): Unit = {
      val jsDir = new File(context.getRealPath("js"))
      val dest = Paths.get(jsDir.getAbsolutePath, "local.config.js")
      if (existsUnderMyContext("js/local.config.js")) {
          logger.info(s"setLocalConfigJs: $dest already exists")
      }
      else {
        logger.info(s"setLocalConfigJs: generating $dest")
        jsDir.mkdir()
        val os = new PrintWriter(dest.toFile)
        try {
          os.println("//// generated by orr backend from master configuration:")

          os.println(s"appConfig.orront.rest           = '${cfg.deployment.url}';")
          os.println(s"appConfig.orront.sparqlEndpoint = '${cfg.deployment.sparqlEndpoint}';")

          // In orr-portal, mainPage can start with '//' to dynamically accommodate http or
          // https access there, so let's set it in that way:
          val portalMainPage = cfg.deployment.url.replaceFirst("^https?:", "")
          os.println(s"appConfig.portal.mainPage = '$portalMainPage';")

          os.println(s"appConfig.branding.title = '${cfg.branding.instanceName}';")
          cfg.branding.logo foreach { x ⇒
            os.println(s"appConfig.branding.logo = '$x';")
          }
          cfg.branding.tou foreach { x ⇒
            os.println(s"appConfig.branding.tou = '$x';")
          }
          cfg.branding.contactUs foreach { x ⇒
            os.println(s"appConfig.branding.contactUs = '$x';")
          }

          cfg.recaptcha foreach { x ⇒
            os.println(s"appConfig.recaptcha = { siteKey: '${x.siteKey}' };")
          }

          val orrPortalConfigFileName = "orrportal.config.js"
          val orrPortalConfigFile = new File(configDir, orrPortalConfigFileName)
          if (orrPortalConfigFile.canRead) {
            logger.info(s"Concatenating $orrPortalConfigFile contents into $dest")
            val src = io.Source.fromFile(orrPortalConfigFile)
            val contents = src.mkString
            src.close()
            os.println(s"\n\n//// copied from $orrPortalConfigFileName:")
            os.println(contents)
          }
        }
        finally os.close()
      }
    }

    def adjustIndexHtmls(): Unit = {
      val indexes = List("index.html", "sparql/index.html")

      val googleSnippetOpt = cfg.googleAnalytics map { ga ⇒
        s"""<script>
            |window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
            |ga('create', '${ga.propertyId}', 'auto');
            |ga('send', 'pageview');
            |</script>
            |<script async src='//www.google-analytics.com/analytics.js'></script>
        """.stripMargin
      }

      indexes foreach { indexHtml =>
        val indexPath = Paths.get(context.getRealPath(indexHtml))
        if (indexPath.toFile.exists()) {
          import java.nio.charset.StandardCharsets.UTF_8
          import scala.collection.JavaConversions._
          val contents = Files.readAllLines(indexPath, UTF_8).mkString("\n")

          var newContentsOpt: Option[String] = None

          googleSnippetOpt foreach { snippet =>
            val fragment = snippet + "\n</head>"
            val c = newContentsOpt.getOrElse(contents)
            if (!c.contains(fragment)) {
              newContentsOpt = Some(c.replace("</head>", fragment))
              logger.info(s"adjustIndexHtmls: set google analytics: $indexPath")
            }
          }

          cfg.branding.footer foreach { footer =>
            val fragment = footer + "\n</body>"
            val c = newContentsOpt.getOrElse(contents)
            if (!c.contains(fragment)) {
              newContentsOpt = Some(c.replace("</body>", fragment))
              logger.info(s"adjustIndexHtmls: set footer: $indexPath")
            }
          }

          newContentsOpt foreach { newContents =>
            Files.write(indexPath, newContents.getBytes(UTF_8))
          }
        }
      }
    }
  }
}
